<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>粒子文字效果</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    body {
      background-color: black;
      overflow: hidden;
      min-height: 100vh;
      position: relative;
      font-family: monospace;
      color: #fff;
      font-size: 40px;
    }

    h1 {
      font-family: monospace;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* background-color: transparent; */
      /* opacity: 0; */
    }

    .active::after,
    .active::before {
      content: '';
      position: absolute;
      inset: 0;
    }

    .active::before {
      background-color: black;
      animation: typing 5s steps(7) 500ms forwards;
    }

    /* .active::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 0;
      height: 100%;
      white-space: nowrap;
      overflow: hidden;
      animation: typing 5s steps(8) forwards, blink 500ms infinite;
    } */

    .active::after {
      width: 2px;
      background-color: black;
      animation: typing 5s steps(7) 500ms forwards,
        blink 500ms infinite;
    }

    @keyframes blink {

      from,
      to {
        background: transparent;
      }

      50% {
        background: #fff;
      }
    }

    @keyframes typing {
      to {
        left: 100%;
      }
    }

    /* 音乐控件样式 */
    .music-control {
      position: fixed;
      bottom: 20px;
      right: 20px;
      color: white;
      cursor: pointer;
      padding: 10px;
      background: pink;
      border-radius: 5px;
    }

    .check {
      font-family: Arial, Helvetica, sans-serif;
      font-size: 40px;
      position: absolute;
      visibility: hidden;
    }
  </style>
</head>

<body>
  <audio autoplay controls loop class="music-control">
    <source src="your-music.mp3" type="audio/mpeg">
    您的浏览器不支持 audio 标签
  </audio>

  <h1 class="active"></h1>
  <h1></h1>



  <canvas id="canvas"></canvas>


  <script>
    let textArr = ['李冰阳生日快乐', '生日快乐冰阳哈']
    const h1 = document.querySelectorAll('h1')
    let i = 0;
    function textChange() {
      setInterval(() => {
        // 移除前一个h1的所有'active'类
        h1[i].classList.remove('active');
        let j = i
        // 更新索引，循环回到第一个元素
        i = (i + 1) % textArr.length;

        // 更新当前h1的内容和样式
        h1[i].textContent = textArr[i];
        h1[j].style.opacity = 0;
        h1[i].style.opacity = 1;
        h1[i].classList.add('active');

      }, 7000); // 每3秒切换一次
    }


    // 初始化第一个h1元素
    if (h1.length > 0) {
      h1[0].textContent = textArr[0];
      h1[0].classList.add('active');
    }

    textChange();

    const canvas = document.querySelector("#canvas")
    const ctx = canvas.getContext('2d')
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight

    const textCanvas = document.createElement('canvas')
    const tctx = textCanvas.getContext('2d')
    const colors = ['#ffa502', '#ff6348', '#ff4757', '#2ed573', '#1e90ff', '#3742fa']
    const strs = ['生日快乐！']
    let particalArr = []
    let index = 0

    // 获取文字尺寸
    const ch = str => {
      const span = document.createElement('span')
      span.className = 'check'
      span.textContent = str
      document.body.appendChild(span)
      const rect = span.getBoundingClientRect()
      document.body.removeChild(span)
      return [rect.width + 180, rect.height - 60]
    }

    // 生成文字图像数据
    const textdata = i => {
      const [w, h] = ch(strs[i])
      textCanvas.width = w || 1
      textCanvas.height = h || 1

      tctx.clearRect(0, 0, textCanvas.width, textCanvas.height)
      tctx.font = '40px Arial'
      tctx.textBaseline = 'top'
      tctx.fillStyle = '#fff'
      tctx.fillText(strs[i], 0, 0)

      return tctx.getImageData(0, 0, textCanvas.width, textCanvas.height)
    }

    class Particle {
      constructor(x, y) {
        this.x = x
        this.y = y
        this.color = colors[Math.floor(Math.random() * colors.length)]
        this.vy = Math.random() - 1.5
        this.vx = 0.5 - Math.random()
        this.g = 0.05
        this.wait = 40
      }
      update() {
        if (this.wait < 0) {
          this.y += this.vy * 2
          this.x += this.vx * 2
          this.vy += this.g
        }
        this.wait--
      }
      draw() {
        ctx.beginPath()
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2)
        ctx.fillStyle = this.color
        ctx.fill()
      }
    }

    const init = () => {
      const pixs = textdata(index % strs.length)
      const offsetX = (canvas.width - textCanvas.width * 5) / 2
      const offsetY = (canvas.height - textCanvas.height * 5) / 2

      for (let i = 0; i < pixs.data.length / 4; i++) {
        if (pixs.data[i * 4 + 3] > 128) {  // 优化透明度判断
          const x = (i % textCanvas.width) * 5 + offsetX
          const y = (Math.floor(i / textCanvas.width)) * 5 + offsetY
          particalArr.push(new Particle(x, y))
        }
      }
      index++
    }

    const animate = () => {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'
      ctx.fillRect(0, 0, canvas.width, canvas.height)

      particalArr.forEach((p, i) => {
        p.update()
        p.draw()
        if (p.y > canvas.height || p.x < 0 || p.x > canvas.width) {
          particalArr.splice(i, 1)
        }
      })

      if (particalArr.length === 0) {
        init()
      }
      requestAnimationFrame(animate)
    }

    init()
    let t = setTimeout(() => {
      show = false
      animate()
    }, 6000)

  </script>
</body>

</html>